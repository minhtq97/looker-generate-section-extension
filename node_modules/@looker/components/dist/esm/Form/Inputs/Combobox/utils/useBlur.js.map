{"version":3,"file":"useBlur.js","names":["useContext","ComboboxActionType","ComboboxState","useBlur","context","data","inputValue","state","transition","listRef","inputElement","freeInputPropRef","shouldRenderListInline","closeList","action","payload","current","undefined","handleBlur","e","IDLE","ESCAPE","nextFocusTarget","relatedTarget","popoverCurrent","focusInList","contains","INTERACTING","INTERACT","BLUR","preventDefault"],"sources":["../../../../../../src/Form/Inputs/Combobox/utils/useBlur.ts"],"sourcesContent":["/**\n * Copyright (c) 2023 Google LLC\n * SPDX-License-Identifier: MIT\n */\n\n// Much of the following is pulled from https://github.com/reach/reach-ui\n// because their work is fantastic (but is not in TypeScript)\nimport type { Context, FocusEvent } from 'react';\nimport { useContext } from 'react';\nimport type {\n  ComboboxContextProps,\n  ComboboxMultiContextProps,\n} from '../ComboboxContext';\nimport { ComboboxActionType, ComboboxState } from './state';\n\nexport function useBlur<\n  TContext extends\n    | ComboboxContextProps\n    | ComboboxMultiContextProps = ComboboxContextProps\n>(context: Context<TContext>) {\n  const {\n    data: { inputValue },\n    state,\n    transition,\n    listRef,\n    inputElement,\n    freeInputPropRef,\n    shouldRenderListInline,\n  } = useContext(context);\n\n  function closeList(action: ComboboxActionType) {\n    // When freeInput is true, the current inputValue should not be changed on blur\n    // (for Multi, InputChips will tokenize the inputValue on blur)\n    const payload =\n      freeInputPropRef && freeInputPropRef.current ? { inputValue } : undefined;\n\n    transition && transition(action, payload);\n  }\n\n  return function handleBlur(e?: FocusEvent) {\n    if (!e) {\n      // handleBlur was called directly (via popover close)\n      // only need to close the list\n      if (!shouldRenderListInline && state !== ComboboxState.IDLE) {\n        closeList(ComboboxActionType.ESCAPE);\n      }\n      return;\n    }\n    // we on want to close only if focus rests outside the select\n    const nextFocusTarget = e.relatedTarget;\n    const popoverCurrent = listRef ? listRef.current : null;\n    if (popoverCurrent) {\n      const focusInList =\n        popoverCurrent && popoverCurrent.contains(nextFocusTarget);\n\n      if (focusInList && state !== ComboboxState.INTERACTING) {\n        // focus landed inside the select, keep it open\n        transition && transition(ComboboxActionType.INTERACT);\n      } else if (!focusInList && nextFocusTarget !== inputElement) {\n        // focus landed outside the select, close it\n        closeList(ComboboxActionType.BLUR);\n      }\n      // Stop ComboboxMultiInput + freeInput underlying InputChips blur handler from\n      // tokenizing input value when an option is clicked\n      focusInList &&\n        freeInputPropRef &&\n        freeInputPropRef.current &&\n        e.preventDefault();\n    }\n  };\n}\n"],"mappings":"AAQA,SAASA,UAAU,QAAQ,OAAO;AAKlC,SAASC,kBAAkB,EAAEC,aAAa,QAAQ,SAAS;AAE3D,OAAO,SAASC,OAAOA,CAIrBC,OAA0B,EAAE;EAC5B,MAAM;IACJC,IAAI,EAAE;MAAEC;IAAW,CAAC;IACpBC,KAAK;IACLC,UAAU;IACVC,OAAO;IACPC,YAAY;IACZC,gBAAgB;IAChBC;EACF,CAAC,GAAGZ,UAAU,CAACI,OAAO,CAAC;EAEvB,SAASS,SAASA,CAACC,MAA0B,EAAE;IAG7C,MAAMC,OAAO,GACXJ,gBAAgB,IAAIA,gBAAgB,CAACK,OAAO,GAAG;MAAEV;IAAW,CAAC,GAAGW,SAAS;IAE3ET,UAAU,IAAIA,UAAU,CAACM,MAAM,EAAEC,OAAO,CAAC;EAC3C;EAEA,OAAO,SAASG,UAAUA,CAACC,CAAc,EAAE;IACzC,IAAI,CAACA,CAAC,EAAE;MAGN,IAAI,CAACP,sBAAsB,IAAIL,KAAK,KAAKL,aAAa,CAACkB,IAAI,EAAE;QAC3DP,SAAS,CAACZ,kBAAkB,CAACoB,MAAM,CAAC;MACtC;MACA;IACF;IAEA,MAAMC,eAAe,GAAGH,CAAC,CAACI,aAAa;IACvC,MAAMC,cAAc,GAAGf,OAAO,GAAGA,OAAO,CAACO,OAAO,GAAG,IAAI;IACvD,IAAIQ,cAAc,EAAE;MAClB,MAAMC,WAAW,GACfD,cAAc,IAAIA,cAAc,CAACE,QAAQ,CAACJ,eAAe,CAAC;MAE5D,IAAIG,WAAW,IAAIlB,KAAK,KAAKL,aAAa,CAACyB,WAAW,EAAE;QAEtDnB,UAAU,IAAIA,UAAU,CAACP,kBAAkB,CAAC2B,QAAQ,CAAC;MACvD,CAAC,MAAM,IAAI,CAACH,WAAW,IAAIH,eAAe,KAAKZ,YAAY,EAAE;QAE3DG,SAAS,CAACZ,kBAAkB,CAAC4B,IAAI,CAAC;MACpC;MAGAJ,WAAW,IACTd,gBAAgB,IAChBA,gBAAgB,CAACK,OAAO,IACxBG,CAAC,CAACW,cAAc,CAAC,CAAC;IACtB;EACF,CAAC;AACH"}