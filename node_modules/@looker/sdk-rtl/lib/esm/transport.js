function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
import { matchCharsetUtf8, matchModeBinary, matchModeString } from './constants';
import { DelimArray } from './delimArray';
import { LookerSDKError } from './lookerSDKError';
import { sleep } from './sleep';
export var agentPrefix = 'TS-SDK';
export var LookerAppId = 'x-looker-appid';
export var MaxTries = 3;
var tracing = false;
export function trace(message, info) {
  if (tracing) {
    console.debug(message);
    if (info) {
      console.debug({
        info
      });
    }
  }
}
export function canRetry(statusCode) {
  return statusCode === StatusCode.Accepted || statusCode === StatusCode.TooManyRequests || statusCode === StatusCode.ServiceUnavailable;
}
export var ResponseMode = function (ResponseMode) {
  ResponseMode[ResponseMode["binary"] = 0] = "binary";
  ResponseMode[ResponseMode["string"] = 1] = "string";
  ResponseMode[ResponseMode["unknown"] = 2] = "unknown";
  return ResponseMode;
}({});
export var contentPatternString = new RegExp(matchModeString, 'i');
export var contentPatternBinary = new RegExp(matchModeBinary, 'i');
export var charsetUtf8Pattern = new RegExp(matchCharsetUtf8, 'i');
export var defaultTimeout = 120;
export var StatusCode = function (StatusCode) {
  StatusCode[StatusCode["OK"] = 200] = "OK";
  StatusCode[StatusCode["Created"] = 201] = "Created";
  StatusCode[StatusCode["Accepted"] = 202] = "Accepted";
  StatusCode[StatusCode["NonAuthoritative"] = 203] = "NonAuthoritative";
  StatusCode[StatusCode["NoContent"] = 204] = "NoContent";
  StatusCode[StatusCode["ResetContent"] = 205] = "ResetContent";
  StatusCode[StatusCode["PartialContent"] = 206] = "PartialContent";
  StatusCode[StatusCode["MultiStatus"] = 207] = "MultiStatus";
  StatusCode[StatusCode["MultiStatusDav"] = 208] = "MultiStatusDav";
  StatusCode[StatusCode["IMUsed"] = 226] = "IMUsed";
  StatusCode[StatusCode["MultipleChoice"] = 300] = "MultipleChoice";
  StatusCode[StatusCode["MovedPermanently"] = 301] = "MovedPermanently";
  StatusCode[StatusCode["Found"] = 302] = "Found";
  StatusCode[StatusCode["SeeOther"] = 303] = "SeeOther";
  StatusCode[StatusCode["NotModified"] = 304] = "NotModified";
  StatusCode[StatusCode["UseProxy"] = 305] = "UseProxy";
  StatusCode[StatusCode["UnusedRedirect"] = 306] = "UnusedRedirect";
  StatusCode[StatusCode["TemporaryRedirect"] = 307] = "TemporaryRedirect";
  StatusCode[StatusCode["PermanentRedirect"] = 308] = "PermanentRedirect";
  StatusCode[StatusCode["BadRequest"] = 400] = "BadRequest";
  StatusCode[StatusCode["Unauthorized"] = 401] = "Unauthorized";
  StatusCode[StatusCode["PaymentRequired"] = 402] = "PaymentRequired";
  StatusCode[StatusCode["Forbidden"] = 403] = "Forbidden";
  StatusCode[StatusCode["NotFound"] = 404] = "NotFound";
  StatusCode[StatusCode["MethodNotAllowed"] = 405] = "MethodNotAllowed";
  StatusCode[StatusCode["NotAcceptable"] = 406] = "NotAcceptable";
  StatusCode[StatusCode["ProxyAuthRequired"] = 407] = "ProxyAuthRequired";
  StatusCode[StatusCode["RequestTimeout"] = 408] = "RequestTimeout";
  StatusCode[StatusCode["Conflict"] = 409] = "Conflict";
  StatusCode[StatusCode["Gone"] = 410] = "Gone";
  StatusCode[StatusCode["LengthRequired"] = 411] = "LengthRequired";
  StatusCode[StatusCode["PreconditionFailed"] = 412] = "PreconditionFailed";
  StatusCode[StatusCode["PayloadTooLarge"] = 413] = "PayloadTooLarge";
  StatusCode[StatusCode["UriTooLong"] = 414] = "UriTooLong";
  StatusCode[StatusCode["UnsupportedMediaType"] = 415] = "UnsupportedMediaType";
  StatusCode[StatusCode["RequestedRangeNotSatisfiable"] = 416] = "RequestedRangeNotSatisfiable";
  StatusCode[StatusCode["ExpectationFailed"] = 417] = "ExpectationFailed";
  StatusCode[StatusCode["ImATeapot"] = 418] = "ImATeapot";
  StatusCode[StatusCode["MisdirectedRequest"] = 421] = "MisdirectedRequest";
  StatusCode[StatusCode["UnprocessableEntity"] = 422] = "UnprocessableEntity";
  StatusCode[StatusCode["Locked"] = 423] = "Locked";
  StatusCode[StatusCode["FailedDependency"] = 424] = "FailedDependency";
  StatusCode[StatusCode["TooEarly"] = 425] = "TooEarly";
  StatusCode[StatusCode["UpgradeRequired"] = 426] = "UpgradeRequired";
  StatusCode[StatusCode["PreconditionRequired"] = 428] = "PreconditionRequired";
  StatusCode[StatusCode["TooManyRequests"] = 429] = "TooManyRequests";
  StatusCode[StatusCode["RequestHeaderFieldsTooLarge"] = 431] = "RequestHeaderFieldsTooLarge";
  StatusCode[StatusCode["UnavailableForLegalReasons"] = 451] = "UnavailableForLegalReasons";
  StatusCode[StatusCode["InternalServerError"] = 500] = "InternalServerError";
  StatusCode[StatusCode["NotImplemented"] = 501] = "NotImplemented";
  StatusCode[StatusCode["BadGateway"] = 502] = "BadGateway";
  StatusCode[StatusCode["ServiceUnavailable"] = 503] = "ServiceUnavailable";
  StatusCode[StatusCode["GatewayTimeout"] = 504] = "GatewayTimeout";
  StatusCode[StatusCode["HttpVersionNotSupported"] = 505] = "HttpVersionNotSupported";
  StatusCode[StatusCode["VariantAlsoNegotiates"] = 506] = "VariantAlsoNegotiates";
  StatusCode[StatusCode["InsufficientStorage"] = 507] = "InsufficientStorage";
  StatusCode[StatusCode["LoopDetected"] = 508] = "LoopDetected";
  StatusCode[StatusCode["NotExtended"] = 510] = "NotExtended";
  StatusCode[StatusCode["NetworkAuthRequired"] = 511] = "NetworkAuthRequired";
  return StatusCode;
}({});
export function responseMode(contentType) {
  if (contentType.match(contentPatternString)) {
    return ResponseMode.string;
  }
  if (contentType.match(contentPatternBinary)) {
    return ResponseMode.binary;
  }
  return ResponseMode.unknown;
}
export function isUtf8(contentType) {
  return contentType.match(/;.*\bcharset\b=\butf-8\b/i);
}
export function encodeParam(value) {
  if (value instanceof Date) {
    value = value.toISOString();
  } else if (value instanceof DelimArray) {
    value = value.toString();
  }
  var encoded = typeof value === 'object' ? JSON.stringify(value) : value.toString();
  try {
    var decoded = decodeURIComponent(value);
    if (value === decoded) {
      encoded = encodeURIComponent(value);
    }
  } catch (e) {
    if (e instanceof URIError) {
      encoded = encodeURIComponent(value);
    } else {
      throw e;
    }
  }
  return encoded;
}
export function encodeParams(values) {
  if (!values) return '';
  var keys = Object.keys(values);
  return keys.filter(k => values[k] !== undefined).map(k => k + '=' + encodeParam(values[k])).join('&');
}
export function addQueryParams(path, obj) {
  if (!obj) {
    return path;
  }
  var qp = encodeParams(obj);
  return "".concat(path).concat(qp ? '?' + qp : '');
}
var utf8 = 'utf-8';
function bufferString(val) {
  var result = 'Unknown error';
  try {
    var decoder = new TextDecoder(utf8);
    result = decoder.decode(val);
  } catch (e) {
    try {
      if (val instanceof Buffer) {
        result = Buffer.from(val).toString(utf8);
      } else {
        result = JSON.stringify(val);
      }
    } catch (err) {
      result = JSON.stringify(val);
    }
  }
  return result;
}
export function sdkError(response) {
  if (typeof response === 'string') {
    return new LookerSDKError(response);
  }
  if ('error' in response) {
    var _error = response.error;
    if (typeof _error === 'string') {
      return new LookerSDKError(_error);
    }
    if ('error' in _error) {
      var _result = bufferString(_error.error);
      return new LookerSDKError(_result);
    }
    if ('message' in _error) {
      var _error$errors, _error$documentation_;
      return new LookerSDKError(response.error.message.toString(), {
        errors: (_error$errors = _error === null || _error === void 0 ? void 0 : _error.errors) !== null && _error$errors !== void 0 ? _error$errors : [],
        documentation_url: (_error$documentation_ = _error === null || _error === void 0 ? void 0 : _error.documentation_url) !== null && _error$documentation_ !== void 0 ? _error$documentation_ : ''
      });
    }
    if ('statusMessage' in _error) {
      return new LookerSDKError(_error.statusMessage);
    }
    var result = bufferString(_error);
    return new LookerSDKError(result);
  }
  if ('message' in response) {
    return new LookerSDKError(response.message);
  }
  var error = JSON.stringify(response);
  return new LookerSDKError("Unknown error with SDK method ".concat(error));
}
export function sdkOk(_x) {
  return _sdkOk.apply(this, arguments);
}
function _sdkOk() {
  _sdkOk = _asyncToGenerator(function* (promise) {
    var result = yield promise;
    if (result.ok) {
      return result.value;
    } else {
      throw sdkError(result);
    }
  });
  return _sdkOk.apply(this, arguments);
}
export function safeBase64(u8) {
  var rawBase64 = btoa(String.fromCharCode(...u8));
  return rawBase64.replace(/\+/g, '-').replace(/\//g, '_');
}
export function isErrorLike(error) {
  if (typeof error !== 'object') return false;
  if (!error) return false;
  if (!Object.prototype.hasOwnProperty.call(error, 'message')) return false;
  if (typeof error.message !== 'string') return false;
  return true;
}
export function jittery(attempt) {
  var baseDelayMs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;
  var maxDelayMs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10000;
  var jitterFactor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.5;
  var exponentialDelay = baseDelayMs * Math.pow(2, attempt);
  exponentialDelay = Math.min(exponentialDelay, maxDelayMs);
  var jitter = Math.random() * jitterFactor * exponentialDelay;
  var delayWithJitter = exponentialDelay + jitter;
  return delayWithJitter;
}
export function retryWait(_x2) {
  return _retryWait.apply(this, arguments);
}
function _retryWait() {
  _retryWait = _asyncToGenerator(function* (wait) {
    yield sleep(wait.waitMS);
    return {
      response: 'retry',
      reason: "waited ".concat(wait.waitMS, " ms")
    };
  });
  return _retryWait.apply(this, arguments);
}
export function pauseForRetry(_x3, _x4, _x5) {
  return _pauseForRetry.apply(this, arguments);
}
function _pauseForRetry() {
  _pauseForRetry = _asyncToGenerator(function* (rawRequest, rawResponse, attempt) {
    var waiter = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : retryWait;
    var retryAfter = rawResponse.headers['Retry-After'];
    var after = (retryAfter ? Number(retryAfter) : 1.0) * 1000;
    var jitter = jittery(attempt, after);
    var response = yield waiter({
      request: rawRequest,
      response: rawResponse,
      attempt,
      waitMS: jitter
    });
    return response;
  });
  return _pauseForRetry.apply(this, arguments);
}
export var mergeOptions = (base, custom) => {
  var _base$headers$custom$;
  var headers = (_base$headers$custom$ = _objectSpread(_objectSpread({}, base.headers), custom.headers)) !== null && _base$headers$custom$ !== void 0 ? _base$headers$custom$ : {};
  var result = _objectSpread(_objectSpread(_objectSpread({}, base), custom), {}, {
    headers
  });
  return result;
};
export function initResponse(method, requestPath) {
  return {
    method,
    url: requestPath,
    body: 'no reply at all',
    contentType: 'text/plain',
    ok: false,
    statusCode: 404,
    statusMessage: 'Not found',
    headers: {},
    requestStarted: 0,
    responseCompleted: 0
  };
}
export function retryError(response) {
  response.statusCode = StatusCode.RequestTimeout;
  response.ok = false;
  if (!response.statusMessage) {
    response.statusMessage = 'Retry waiting exited with an error condition';
  }
  return response;
}
export function verifySsl(options) {
  return options && 'verify_ssl' in options ? options.verify_ssl : true;
}
export function sdkTimeout(options) {
  if (options && 'timeout' in options && options.timeout && options.timeout > 0) return options.timeout;
  return defaultTimeout;
}
//# sourceMappingURL=transport.js.map