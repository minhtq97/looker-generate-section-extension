{"version":3,"file":"transport.js","names":["matchCharsetUtf8","matchModeBinary","matchModeString","DelimArray","LookerSDKError","sleep","agentPrefix","LookerAppId","MaxTries","tracing","trace","message","info","console","debug","canRetry","statusCode","StatusCode","Accepted","TooManyRequests","ServiceUnavailable","ResponseMode","contentPatternString","RegExp","contentPatternBinary","charsetUtf8Pattern","defaultTimeout","responseMode","contentType","match","string","binary","unknown","isUtf8","encodeParam","value","Date","toISOString","toString","encoded","JSON","stringify","decoded","decodeURIComponent","encodeURIComponent","e","URIError","encodeParams","values","keys","Object","filter","k","undefined","map","join","addQueryParams","path","obj","qp","concat","utf8","bufferString","val","result","decoder","TextDecoder","decode","Buffer","from","err","sdkError","response","error","_error$errors","_error$documentation_","errors","documentation_url","statusMessage","sdkOk","_x","_sdkOk","apply","arguments","_asyncToGenerator","promise","ok","safeBase64","u8","rawBase64","btoa","String","fromCharCode","replace","isErrorLike","prototype","hasOwnProperty","call","jittery","attempt","baseDelayMs","length","maxDelayMs","jitterFactor","exponentialDelay","Math","pow","min","jitter","random","delayWithJitter","retryWait","_x2","_retryWait","wait","waitMS","reason","pauseForRetry","_x3","_x4","_x5","_pauseForRetry","rawRequest","rawResponse","waiter","retryAfter","headers","after","Number","request","mergeOptions","base","custom","_base$headers$custom$","_objectSpread","initResponse","method","requestPath","url","body","requestStarted","responseCompleted","retryError","RequestTimeout","verifySsl","options","verify_ssl","sdkTimeout","timeout"],"sources":["../../src/transport.ts"],"sourcesContent":["/*\n\n MIT License\n\n Copyright (c) 2021 Looker Data Sciences, Inc.\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in all\n copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n SOFTWARE.\n\n */\n\nimport type { Agent } from 'https';\nimport {\n  matchCharsetUtf8,\n  matchModeBinary,\n  matchModeString,\n} from './constants';\nimport { DelimArray } from './delimArray';\nimport { LookerSDKError } from './lookerSDKError';\nimport type { IAuthSession } from './authSession';\nimport { sleep } from './sleep';\n\nexport const agentPrefix = 'TS-SDK';\nexport const LookerAppId = 'x-looker-appid';\n\n/** default maximum number of retries to attempt */\nexport const MaxTries = 3;\n\n/** Set to `true` to turn on tracing wherever it may be referenced in the sdk */\nconst tracing = false;\n\n/**\n * trivial tracing function that should be replaced with a log plugin\n * @param message description for trace\n * @param info any additional information to produce for output\n */\nexport function trace(message: string, info?: any) {\n  if (tracing) {\n    // eslint-disable-next-line no-console\n    console.debug(message);\n    if (info) {\n      // eslint-disable-next-line no-console\n      console.debug({ info });\n    }\n  }\n}\n\n/**\n * is this status code retryable?\n *\n * @returns true if statusCode is 202, 429, or 503\n * @param statusCode HTTP status code\n *\n */\nexport function canRetry(statusCode: number) {\n  return (\n    statusCode === StatusCode.Accepted ||\n    statusCode === StatusCode.TooManyRequests ||\n    statusCode === StatusCode.ServiceUnavailable\n  );\n}\n\n/** ResponseMode for an HTTP request */\nexport enum ResponseMode {\n  'binary', // this is a binary response\n  'string', // this is a \"string\" response\n  'unknown', // unrecognized response type\n}\n\n/**\n * MIME patterns for string content types\n * @type {RegExp}\n */\nexport const contentPatternString = new RegExp(matchModeString, 'i');\n\n/**\n * MIME patterns for \"binary\" content types\n * @type {RegExp}\n */\nexport const contentPatternBinary = new RegExp(matchModeBinary, 'i');\n\n/**\n * MIME pattern for UTF8 charset attribute\n * @type {RegExp}\n */\nexport const charsetUtf8Pattern = new RegExp(matchCharsetUtf8, 'i');\n\n/**\n * Default request timeout\n * @type {number} default request timeout is 120 seconds, or two minutes\n */\nexport const defaultTimeout = 120;\n\n/** Recognized HTTP methods */\nexport type HttpMethod =\n  | 'GET'\n  | 'POST'\n  | 'PUT'\n  | 'DELETE'\n  | 'PATCH'\n  | 'TRACE'\n  | 'HEAD';\n\n/**\n * HTTP status codes\n * https://developer.mozilla.org/en-US/docs/Web/HTTP/Status for reference\n * TODO is there a platform-agnostic list of these that can be used instead of this static declaration?\n */\nexport enum StatusCode {\n  OK = 200,\n  Created,\n  Accepted,\n  NonAuthoritative,\n  NoContent,\n  ResetContent,\n  PartialContent,\n  MultiStatus,\n  MultiStatusDav,\n  IMUsed = 226,\n  MultipleChoice = 300,\n  MovedPermanently,\n  Found,\n  SeeOther,\n  NotModified,\n  UseProxy,\n  UnusedRedirect,\n  TemporaryRedirect,\n  PermanentRedirect,\n  BadRequest = 400,\n  Unauthorized,\n  PaymentRequired,\n  Forbidden,\n  NotFound,\n  MethodNotAllowed,\n  NotAcceptable,\n  ProxyAuthRequired,\n  RequestTimeout,\n  Conflict,\n  Gone,\n  LengthRequired,\n  PreconditionFailed,\n  PayloadTooLarge,\n  UriTooLong,\n  UnsupportedMediaType,\n  RequestedRangeNotSatisfiable,\n  ExpectationFailed,\n  ImATeapot,\n  MisdirectedRequest = 421,\n  UnprocessableEntity,\n  Locked,\n  FailedDependency,\n  TooEarly,\n  UpgradeRequired,\n  PreconditionRequired = 428,\n  TooManyRequests,\n  RequestHeaderFieldsTooLarge = 431,\n  UnavailableForLegalReasons = 451,\n  InternalServerError = 500,\n  NotImplemented,\n  BadGateway,\n  ServiceUnavailable,\n  GatewayTimeout,\n  HttpVersionNotSupported,\n  VariantAlsoNegotiates,\n  InsufficientStorage,\n  LoopDetected,\n  NotExtended = 510,\n  NetworkAuthRequired,\n}\n\n/** Property bag for submitting an HTTP request */\nexport interface IRawRequest {\n  /** HTTP request method */\n  method: HttpMethod;\n  /** HTTP Request path */\n  path: string;\n  /** optional query parameters collection */\n  queryParams?: Values;\n  /** optional request body */\n  body?: any;\n  /** optional API authenticator callback */\n  authenticator?: Authenticator;\n  /** optional transport settings overrides */\n  options?: Partial<ITransportSettings>;\n}\n\n/** Untyped basic HTTP response type for \"raw\" HTTP requests */\nexport interface IRawResponse {\n  /** Http method of the request */\n  method: HttpMethod;\n  /** ok is `true` if the response is successful, `false` otherwise */\n  ok: boolean;\n  /** HTTP request url */\n  url: string;\n  /** HTTP response code */\n  statusCode: number;\n  /** HTTP response status message text */\n  statusMessage: string;\n  /** MIME type of the response from the HTTP response header */\n  contentType: string;\n  /** The body of the HTTP response, without any additional processing */\n  body: any;\n  /** Optional performance tracking starting mark name */\n  startMark?: string;\n  /** Response headers */\n  headers: IRequestHeaders;\n  /** Request start time */\n  requestStarted: number;\n  /** Completion time for request */\n  responseCompleted: number;\n}\n\n/** IRawResponse observer function type */\nexport type RawObserver = (raw: IRawResponse) => IRawResponse;\n\n/** A successful SDK call. */\nexport interface ISDKSuccessResponse<T> {\n  /** Whether the SDK call was successful. */\n  ok: true;\n  /** The object returned by the SDK call. */\n  value: T;\n}\n\n/** An errant SDK call. */\nexport interface ISDKErrorResponse<T> {\n  /** Whether the SDK call was successful. */\n  ok: false;\n  /** The error object returned by the SDK call. */\n  error: T;\n}\n\n/** An error representing an issue in the SDK, like a network or parsing error. */\nexport interface ISDKError {\n  type: 'sdk_error';\n  message: string;\n}\n\nexport type SDKResponse<TSuccess, TError> =\n  | ISDKSuccessResponse<TSuccess>\n  | ISDKErrorResponse<TError | ISDKError>;\n\n/** Keyed string hash */\nexport interface IRequestHeaders {\n  [key: string]: string;\n}\n\n/**\n * Generic http request property collection\n * TODO: Trim this down to what is required\n */\nexport interface IRequestProps {\n  [key: string]: any;\n  /** full url for request, including any query params */\n  url: string;\n\n  /** body of request. optional */\n  body?: any;\n  /** headers for request. optional */\n  headers: IRequestHeaders;\n  /** Http method for request. required. */\n  method: HttpMethod;\n  /** Redirect processing for request. optional */\n  redirect?: any;\n  /** Credentials to use */\n  credentials?: 'include' | 'omit' | 'same-origin' | undefined;\n\n  /** http.Agent instance, allows custom proxy, certificate etc. */\n  agent?: Agent;\n  /** support gzip/deflate content encoding. false to disable */\n  compress?: boolean;\n  /** maximum redirect count. 0 to not follow redirect */\n  follow?: number;\n  /** maximum response body size in bytes */\n  size?: number;\n  /** req/res timeout in ms, it resets on redirect. 0 to disable (OS limit applies) */\n  timeout?: number;\n}\n\n/** General purpose authentication callback */\nexport type Authenticator = (props: any) => any;\n\n/** Alpha: Properties for an async Waitable retry handler */\nexport interface IWait {\n  /** HTTP request that responded with a retry code */\n  request: IRawRequest;\n  /** HTTP response that is a retry */\n  response: IRawResponse;\n  /** Attempt number for the retry */\n  attempt: number;\n  /** Time in milliseconds to wait before retrying */\n  waitMS: number;\n}\n\n/** Alpha: Response from a Waitable function */\nexport interface IWaitResponse {\n  /** cancel, retry, or error are the allowed responses for the retryable waiter */\n  response: 'cancel' | 'retry' | 'error';\n  /** Optional reason for the response */\n  reason?: string;\n}\n\n/** Alpha: Waitable function override for retrying an HTTP request */\nexport type Waitable = (waiting: IWait) => Promise<IWaitResponse>;\n\n/** Interface for API transport values */\nexport interface ITransportSettings {\n  [key: string]: any;\n  /** base URL of API REST web service */\n  base_url: string;\n  /** standard headers to provide in all transport requests */\n  headers?: IRequestHeaders;\n  /** whether to verify ssl certs or not. Defaults to true */\n  verify_ssl: boolean;\n  /** request timeout in seconds. Default to 30 */\n  timeout: number;\n  /** encoding override */\n  encoding?: string | null;\n  /** agent tag to use for the SDK requests */\n  agentTag: string;\n  /** maximum number of times for a retry response */\n  maxTries?: number;\n  /** override for awaiting retry requests */\n  waitHandler?: Waitable;\n  /** abort controller signal customization */\n  signal?: AbortSignal;\n}\n\n/** Transport plug-in interface */\nexport interface ITransport {\n  /** Observer lambda to process raw responses */\n  observer: RawObserver | undefined;\n\n  /**\n   * default retryable HTTP request. If maxTries > 1 in the `options`\n   * properties for the SDK, this is where HTTP requests will be retried.\n   */\n  retry(request: IRawRequest): Promise<IRawResponse>;\n\n  /**\n   * HTTP request function for atomic, fully downloaded raw HTTP responses\n   *\n   * Note: This method returns the result of the HTTP request without any error handling\n   *\n   * @param method of HTTP request\n   * @param path request path, either relative or fully specified\n   * @param queryParams name/value pairs to pass as part of the URL\n   * @param body data for the body of the request\n   * @param authenticator authenticator callback, typically from `IAuthSession` implementation\n   * @param options overrides of default transport settings\n   * @returns typed response of `TSuccess`, or `TError` result\n   */\n  rawRequest(\n    method: HttpMethod,\n    path: string,\n    queryParams?: Values,\n    body?: any,\n    authenticator?: Authenticator,\n    options?: Partial<ITransportSettings>\n  ): Promise<IRawResponse>;\n\n  /**\n   * HTTP request function for atomic, fully downloaded responses\n   * @param method of HTTP request\n   * @param path request path, either relative or fully specified\n   * @param queryParams name/value pairs to pass as part of the URL\n   * @param body data for the body of the request\n   * @param authenticator authenticator callback, typically from `IAuthSession` implementation\n   * @param options overrides of default transport settings\n   * @returns typed response of `TSuccess`, or `TError` result\n   */\n  request<TSuccess, TError>(\n    method: HttpMethod,\n    path: string,\n    queryParams?: Values,\n    body?: any,\n    authenticator?: Authenticator,\n    options?: Partial<ITransportSettings>\n  ): Promise<SDKResponse<TSuccess, TError>>;\n\n  /**\n   * Processes the raw response, converting it into an SDKResponse\n   * @param raw response result\n   */\n  parseResponse<TSuccess, TError>(\n    raw: IRawResponse\n  ): Promise<SDKResponse<TSuccess, TError>>;\n\n  /**\n   * HTTP request function for a streamable response\n   * @param callback that receives the stream response and pipes it somewhere\n   * @param method of HTTP request\n   * @param path request path, either relative or fully specified\n   * @param queryParams name/value pairs to pass as part of the URL\n   * @param body data for the body of the request\n   * @param authenticator authenticator callback, typically from `IAuthSession` implementation\n   * @param options overrides of default transport settings\n   * @returns `T` upon success\n   * @throws `ISDKErrorResponse` on failure\n   */\n  stream<T>(\n    callback: (response: Response) => Promise<T>,\n    method: HttpMethod,\n    path: string,\n    queryParams?: Values,\n    body?: any,\n    authenticator?: Authenticator,\n    options?: Partial<ITransportSettings>\n  ): Promise<T>;\n}\n\nexport interface IAPIMethods {\n  authSession: IAuthSession;\n  sdkVersion: string;\n  apiPath: string;\n  apiVersion: string;\n\n  /** A helper method for simplifying error handling of SDK responses.\n   *\n   * Pass in a promise returned by any SDK method, and it will return a promise\n   * that rejects if the `SDKResponse` is not `ok`. This will swallow the type\n   * information in the error case, but allows you to route all the error cases\n   * into a single promise rejection.\n   *\n   * The promise will have an `Error` rejection reason with a string `message`.\n   * If the server error contains a `message` field, it will be provided, otherwise a\n   * generic message will occur.\n   *\n   * ```ts\n   * const sdk = LookerSDK({...})\n   * let look\n   * try {\n   *    look = await sdk.ok(sdk.create_look({...}))\n   *    // do something with look\n   * }\n   * catch(e) {\n   *    // handle error case\n   * }\n   * ```\n   */\n  ok<TSuccess, TError>(\n    promise: Promise<SDKResponse<TSuccess, TError>>\n  ): Promise<TSuccess>;\n\n  /**\n   * Determine whether the url should be an API path, relative from base_url, or is already fully specified override\n   * @param path Request path\n   * @param options Transport settings\n   * @param authenticator optional callback\n   * @returns the fully specified request path including any query string parameters\n   */\n  makePath(\n    path: string,\n    options: Partial<ITransportSettings>,\n    authenticator?: Authenticator\n  ): string;\n\n  /**\n   *\n   * A helper method to add authentication to an API request for deserialization\n   *\n   * @param method type of HTTP method\n   * @param path API endpoint path\n   * @param queryParams Optional query params collection for request\n   * @param body Optional body for request\n   * @param options Optional overrides like timeout and verify_ssl\n   */\n  authRequest<TSuccess, TError>(\n    method: HttpMethod,\n    path: string,\n    queryParams?: Values,\n    body?: any,\n    options?: Partial<ITransportSettings>\n  ): Promise<SDKResponse<TSuccess, TError>>;\n\n  /**\n   * A helper method to add authentication to an API request for streaming\n   * @param callback\n   * @param method HTTP method\n   * @param path HTTP request path\n   * @param queryParams query string parameters\n   * @param body of the request\n   * @param options Optional overrides like timeout and verify_ssl\n   * @returns {Promise<T>}\n   */\n  authStream<T>(\n    callback: (response: Response) => Promise<T>,\n    method: HttpMethod,\n    path: string,\n    queryParams?: Values,\n    body?: any,\n    options?: Partial<ITransportSettings>\n  ): Promise<T>;\n\n  /** Make a GET request */\n  get<TSuccess, TError>(\n    path: string,\n    queryParams?: Values,\n    body?: any,\n    options?: Partial<ITransportSettings>\n  ): Promise<SDKResponse<TSuccess, TError>>;\n\n  /** Make a HEAD request */\n  head<TSuccess, TError>(\n    path: string,\n    queryParams?: Values,\n    body?: any,\n    options?: Partial<ITransportSettings>\n  ): Promise<SDKResponse<TSuccess, TError>>;\n\n  /** Make a DELETE request */\n  delete<TSuccess, TError>(\n    path: string,\n    queryParams?: Values,\n    body?: any,\n    options?: Partial<ITransportSettings>\n  ): Promise<SDKResponse<TSuccess, TError>>;\n\n  /** Make a POST request */\n  post<TSuccess, TError>(\n    path: string,\n    queryParams?: Values,\n    body?: any,\n    options?: Partial<ITransportSettings>\n  ): Promise<SDKResponse<TSuccess, TError>>;\n\n  /** Make a PUT request */\n  put<TSuccess, TError>(\n    path: string,\n    queryParams?: Values,\n    body?: any,\n    options?: Partial<ITransportSettings>\n  ): Promise<SDKResponse<TSuccess, TError>>;\n\n  /** Make a PATCH request */\n  patch<TSuccess, TError>(\n    path: string,\n    queryParams?: Values,\n    body?: any,\n    options?: Partial<ITransportSettings>\n  ): Promise<SDKResponse<TSuccess, TError>>;\n}\n\n/**\n * Is the content type binary or \"string\"?\n * @param contentType MIME content type description\n * @returns {ResponseMode.binary | ResponseMode.string}\n */\nexport function responseMode(contentType: string) {\n  if (contentType.match(contentPatternString)) {\n    return ResponseMode.string;\n  }\n  if (contentType.match(contentPatternBinary)) {\n    return ResponseMode.binary;\n  }\n  return ResponseMode.unknown;\n}\n\n/**\n * Does this content type have a UTF-8 charset?\n * @param contentType\n * @returns match if it exists\n */\nexport function isUtf8(contentType: string) {\n  return contentType.match(/;.*\\bcharset\\b=\\butf-8\\b/i);\n}\n\n/** Used for name/value pair collections like for QueryParams */\nexport type Values = { [key: string]: any } | null | undefined;\n\n/**\n * Encode parameter if not already encoded\n *\n * Note: this includes recognition of Date, DelimArray, and default objects for special handling\n *\n * @param value value of parameter\n * @returns URI encoded value\n */\nexport function encodeParam(value: any) {\n  if (value instanceof Date) {\n    value = value.toISOString();\n  } else if (value instanceof DelimArray) {\n    value = value.toString();\n  }\n  // check for object type to prevent \"[object Object]\" as the value.toString()\n  let encoded =\n    typeof value === 'object' ? JSON.stringify(value) : value.toString();\n\n  // decodeURIComponent throws URIError if there is a % character\n  // without it being part of an encoded\n  try {\n    const decoded = decodeURIComponent(value);\n    if (value === decoded) {\n      encoded = encodeURIComponent(value);\n    }\n  } catch (e) {\n    if (e instanceof URIError) {\n      encoded = encodeURIComponent(value);\n    } else {\n      throw e;\n    }\n  }\n  return encoded;\n}\n\n/**\n * Converts `Values` to query string parameter format\n * @param values Name/value collection to encode\n * @returns {string} query string parameter formatted values. Both `false` and `null` are included. Only `undefined` are omitted.\n */\nexport function encodeParams(values?: Values) {\n  if (!values) return '';\n\n  const keys = Object.keys(values);\n  return keys\n    .filter(k => values[k] !== undefined) // `null` and `false` will both be passed\n    .map(k => k + '=' + encodeParam(values[k]))\n    .join('&');\n}\n\n/**\n * constructs the path argument including any optional query parameters\n * @param path the base path of the request\n * @param obj optional collection of query parameters to encode and append to the path\n */\nexport function addQueryParams(path: string, obj?: Values) {\n  if (!obj) {\n    return path;\n  }\n  const qp = encodeParams(obj);\n  return `${path}${qp ? '?' + qp : ''}`;\n}\n\nconst utf8 = 'utf-8';\n\n/**\n * Convert this value to a string representation however we can do it\n * @param val\n */\nfunction bufferString(val: any) {\n  let result = 'Unknown error';\n  try {\n    const decoder = new TextDecoder(utf8);\n    result = decoder.decode(val);\n  } catch (e: any) {\n    // Supremely ugly hack. If we get here, we must be in Node (or IE 11, but who cares about that?)\n    // Node requires an import from `util` for TextDecoder to be found BUT it \"just has\" Buffer unless WebPack messes us up\n    try {\n      if (val instanceof Buffer) {\n        result = Buffer.from(val).toString(utf8);\n      } else {\n        result = JSON.stringify(val);\n      }\n    } catch (err: any) {\n      // The fallback logic here will at least give us some information about the error being thrown\n      result = JSON.stringify(val);\n    }\n  }\n  return result;\n}\n\n/**\n * SDK error handler\n * @param response any kind of error\n * @returns a new `Error` object with the failure message\n */\nexport function sdkError(response: any) {\n  if (typeof response === 'string') {\n    return new LookerSDKError(response);\n  }\n  if ('error' in response) {\n    const error = response.error;\n    if (typeof error === 'string') {\n      return new LookerSDKError(error);\n    }\n    // Try to get most specific error first\n    if ('error' in error) {\n      const result = bufferString(error.error);\n      return new LookerSDKError(result);\n    }\n    if ('message' in error) {\n      return new LookerSDKError(response.error.message.toString(), {\n        errors: error?.errors ?? [],\n        documentation_url: error?.documentation_url ?? '',\n      });\n    }\n    if ('statusMessage' in error) {\n      return new LookerSDKError(error.statusMessage);\n    }\n    const result = bufferString(error);\n    return new LookerSDKError(result);\n  }\n  if ('message' in response) {\n    return new LookerSDKError(response.message);\n  }\n  const error = JSON.stringify(response);\n  return new LookerSDKError(`Unknown error with SDK method ${error}`);\n}\n\n/** A helper method for simplifying error handling of SDK responses.\n *\n * Pass in a promise returned by any SDK method, and it will return a promise\n * that rejects if the `SDKResponse` is not `ok`. This will swallow the type\n * information in the error case, but allows you to route all the error cases\n * into a single promise rejection.\n *\n * The promise will have an `Error` rejection reason with a string `message`.\n * If the server error contains a `message` field, it will be provided, otherwise a\n * generic message will occur.\n *\n * ```ts\n * const sdk = LookerSDK({...})\n * let look\n * try {\n *    look = await sdkOk(sdk.create_look({...}))\n *    // do something with look\n * }\n * catch(e) {\n *    // handle error case\n * }\n * ```\n */\nexport async function sdkOk<TSuccess, TError>(\n  promise: Promise<SDKResponse<TSuccess, TError>>\n) {\n  const result = await promise;\n  if (result.ok) {\n    return result.value;\n  } else {\n    throw sdkError(result);\n  }\n}\n\n/**\n * Converts a byte array to a \"URL safe\" base64 string\n * @param u8 byte array to convert\n */\nexport function safeBase64(u8: Uint8Array) {\n  const rawBase64 = btoa(String.fromCharCode(...u8));\n  return rawBase64.replace(/\\+/g, '-').replace(/\\//g, '_');\n}\n\n/**\n * Type predicate. Asserts that a given object is error-like.\n * @param error a value of unknown type\n * @return boolean true if the error has a `message` key of type string.\n */\nexport function isErrorLike<T>(error: T): error is T & { message: string } {\n  if (typeof error !== 'object') return false;\n  if (!error) return false;\n  if (!Object.prototype.hasOwnProperty.call(error, 'message')) return false;\n  if (typeof (error as unknown as { message: unknown }).message !== 'string')\n    return false;\n  return true;\n}\n\n/**\n * Calculate complete delay for exponential backoff/retry with jitter\n * @param attempt count of attempts\n * @param baseDelayMs minimum delay, based on `Retry-After` header\n * @param maxDelayMs maximum delay to allow\n * @param jitterFactor multiplication factor for jitter value\n */\nexport function jittery(\n  attempt: number,\n  baseDelayMs = 1000,\n  maxDelayMs = 10000,\n  jitterFactor = 0.5\n): number {\n  // Exponential Backoff: Double the delay with each retry\n  let exponentialDelay = baseDelayMs * Math.pow(2, attempt);\n\n  // Cap the delay to prevent excessive wait times\n  exponentialDelay = Math.min(exponentialDelay, maxDelayMs);\n\n  // Apply Jitter: Introduce randomness to avoid retry collisions\n  const jitter = Math.random() * jitterFactor * exponentialDelay;\n  const delayWithJitter = exponentialDelay + jitter;\n\n  return delayWithJitter;\n}\n\n/**\n * Default retry waiting function. Called after jitter period is calculated\n * @param wait parameters for request/response/attempt and wait time\n */\nexport async function retryWait(wait: IWait): Promise<IWaitResponse> {\n  await sleep(wait.waitMS);\n  return { response: 'retry', reason: `waited ${wait.waitMS} ms` };\n}\n\n/**\n * Calculate the jitter time and call the waiter\n * @param rawRequest request that had a retry. `options.maxTries` is available here.\n * @param rawResponse retry response\n * @param attempt count of attempts made.\n * @param waiter function to perform waiting process\n */\nexport async function pauseForRetry(\n  rawRequest: IRawRequest,\n  rawResponse: IRawResponse,\n  attempt: number,\n  waiter: Waitable = retryWait\n) {\n  // calculate minimum delay in MS\n  const retryAfter = rawResponse.headers['Retry-After'];\n  const after = (retryAfter ? Number(retryAfter) : 1.0) * 1000;\n  // randomize the retry\n  const jitter = jittery(attempt, after);\n  const response = await waiter({\n    request: rawRequest,\n    response: rawResponse,\n    attempt,\n    waitMS: jitter,\n  });\n  return response;\n}\n\n/**\n * Merge base settings with custom settings, ensuring no header overrides are lost\n * @param base settings\n * @param custom settings\n */\nexport const mergeOptions = (\n  base: Partial<ITransportSettings>,\n  custom: Partial<ITransportSettings>\n): Partial<ITransportSettings> => {\n  const headers = { ...base.headers, ...custom.headers } ?? {};\n  const result = { ...base, ...custom, headers };\n  return result;\n};\n\n/**\n * Create a default \"no reply\" response object for retry loops\n * @param method Http method for initialization\n * @param requestPath Http path for request to initialize\n */\nexport function initResponse(\n  method: HttpMethod,\n  requestPath: string\n): IRawResponse {\n  return {\n    method,\n    url: requestPath,\n    body: 'no reply at all',\n    contentType: 'text/plain',\n    ok: false,\n    statusCode: 404,\n    statusMessage: 'Not found',\n    headers: {},\n    requestStarted: 0,\n    responseCompleted: 0,\n  };\n}\n\n/**\n * Modify and return response object indicating retry waiting had an error\n * @param response to modify\n */\nexport function retryError(response: IRawResponse): IRawResponse {\n  // retry wait function decided on 'error' so throw an error equivalent\n  response.statusCode = StatusCode.RequestTimeout;\n  response.ok = false;\n  if (!response.statusMessage) {\n    response.statusMessage = 'Retry waiting exited with an error condition';\n  }\n  return response;\n}\n\n/**\n * should the request verify SSL?\n * @param options Defaults to the instance options values\n * @returns true (the default) if the request should require full SSL verification\n */\nexport function verifySsl(options?: Partial<ITransportSettings>) {\n  return options && 'verify_ssl' in options ? options.verify_ssl : true;\n}\n\n/**\n * Get the HTTP request timeout, in seconds\n *\n * The configured timeout value must be > 0 to be used\n *\n * @param options Defaults to `defaultTimeout`\n */\nexport function sdkTimeout(options?: Partial<ITransportSettings>): number {\n  if (options && 'timeout' in options && options.timeout && options.timeout > 0)\n    return options.timeout;\n  return defaultTimeout;\n}\n"],"mappings":"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"}