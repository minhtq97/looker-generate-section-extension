import type { Agent } from 'https';
import { LookerSDKError } from './lookerSDKError';
import type { IAuthSession } from './authSession';
export declare const agentPrefix = "TS-SDK";
export declare const LookerAppId = "x-looker-appid";
export declare const MaxTries = 3;
export declare function trace(message: string, info?: any): void;
export declare function canRetry(statusCode: number): statusCode is StatusCode.Accepted | StatusCode.TooManyRequests | StatusCode.ServiceUnavailable;
export declare enum ResponseMode {
    'binary' = 0,
    'string' = 1,
    'unknown' = 2
}
export declare const contentPatternString: RegExp;
export declare const contentPatternBinary: RegExp;
export declare const charsetUtf8Pattern: RegExp;
export declare const defaultTimeout = 120;
export type HttpMethod = 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH' | 'TRACE' | 'HEAD';
export declare enum StatusCode {
    OK = 200,
    Created = 201,
    Accepted = 202,
    NonAuthoritative = 203,
    NoContent = 204,
    ResetContent = 205,
    PartialContent = 206,
    MultiStatus = 207,
    MultiStatusDav = 208,
    IMUsed = 226,
    MultipleChoice = 300,
    MovedPermanently = 301,
    Found = 302,
    SeeOther = 303,
    NotModified = 304,
    UseProxy = 305,
    UnusedRedirect = 306,
    TemporaryRedirect = 307,
    PermanentRedirect = 308,
    BadRequest = 400,
    Unauthorized = 401,
    PaymentRequired = 402,
    Forbidden = 403,
    NotFound = 404,
    MethodNotAllowed = 405,
    NotAcceptable = 406,
    ProxyAuthRequired = 407,
    RequestTimeout = 408,
    Conflict = 409,
    Gone = 410,
    LengthRequired = 411,
    PreconditionFailed = 412,
    PayloadTooLarge = 413,
    UriTooLong = 414,
    UnsupportedMediaType = 415,
    RequestedRangeNotSatisfiable = 416,
    ExpectationFailed = 417,
    ImATeapot = 418,
    MisdirectedRequest = 421,
    UnprocessableEntity = 422,
    Locked = 423,
    FailedDependency = 424,
    TooEarly = 425,
    UpgradeRequired = 426,
    PreconditionRequired = 428,
    TooManyRequests = 429,
    RequestHeaderFieldsTooLarge = 431,
    UnavailableForLegalReasons = 451,
    InternalServerError = 500,
    NotImplemented = 501,
    BadGateway = 502,
    ServiceUnavailable = 503,
    GatewayTimeout = 504,
    HttpVersionNotSupported = 505,
    VariantAlsoNegotiates = 506,
    InsufficientStorage = 507,
    LoopDetected = 508,
    NotExtended = 510,
    NetworkAuthRequired = 511
}
export interface IRawRequest {
    method: HttpMethod;
    path: string;
    queryParams?: Values;
    body?: any;
    authenticator?: Authenticator;
    options?: Partial<ITransportSettings>;
}
export interface IRawResponse {
    method: HttpMethod;
    ok: boolean;
    url: string;
    statusCode: number;
    statusMessage: string;
    contentType: string;
    body: any;
    startMark?: string;
    headers: IRequestHeaders;
    requestStarted: number;
    responseCompleted: number;
}
export type RawObserver = (raw: IRawResponse) => IRawResponse;
export interface ISDKSuccessResponse<T> {
    ok: true;
    value: T;
}
export interface ISDKErrorResponse<T> {
    ok: false;
    error: T;
}
export interface ISDKError {
    type: 'sdk_error';
    message: string;
}
export type SDKResponse<TSuccess, TError> = ISDKSuccessResponse<TSuccess> | ISDKErrorResponse<TError | ISDKError>;
export interface IRequestHeaders {
    [key: string]: string;
}
export interface IRequestProps {
    [key: string]: any;
    url: string;
    body?: any;
    headers: IRequestHeaders;
    method: HttpMethod;
    redirect?: any;
    credentials?: 'include' | 'omit' | 'same-origin' | undefined;
    agent?: Agent;
    compress?: boolean;
    follow?: number;
    size?: number;
    timeout?: number;
}
export type Authenticator = (props: any) => any;
export interface IWait {
    request: IRawRequest;
    response: IRawResponse;
    attempt: number;
    waitMS: number;
}
export interface IWaitResponse {
    response: 'cancel' | 'retry' | 'error';
    reason?: string;
}
export type Waitable = (waiting: IWait) => Promise<IWaitResponse>;
export interface ITransportSettings {
    [key: string]: any;
    base_url: string;
    headers?: IRequestHeaders;
    verify_ssl: boolean;
    timeout: number;
    encoding?: string | null;
    agentTag: string;
    maxTries?: number;
    waitHandler?: Waitable;
    signal?: AbortSignal;
}
export interface ITransport {
    observer: RawObserver | undefined;
    retry(request: IRawRequest): Promise<IRawResponse>;
    rawRequest(method: HttpMethod, path: string, queryParams?: Values, body?: any, authenticator?: Authenticator, options?: Partial<ITransportSettings>): Promise<IRawResponse>;
    request<TSuccess, TError>(method: HttpMethod, path: string, queryParams?: Values, body?: any, authenticator?: Authenticator, options?: Partial<ITransportSettings>): Promise<SDKResponse<TSuccess, TError>>;
    parseResponse<TSuccess, TError>(raw: IRawResponse): Promise<SDKResponse<TSuccess, TError>>;
    stream<T>(callback: (response: Response) => Promise<T>, method: HttpMethod, path: string, queryParams?: Values, body?: any, authenticator?: Authenticator, options?: Partial<ITransportSettings>): Promise<T>;
}
export interface IAPIMethods {
    authSession: IAuthSession;
    sdkVersion: string;
    apiPath: string;
    apiVersion: string;
    ok<TSuccess, TError>(promise: Promise<SDKResponse<TSuccess, TError>>): Promise<TSuccess>;
    makePath(path: string, options: Partial<ITransportSettings>, authenticator?: Authenticator): string;
    authRequest<TSuccess, TError>(method: HttpMethod, path: string, queryParams?: Values, body?: any, options?: Partial<ITransportSettings>): Promise<SDKResponse<TSuccess, TError>>;
    authStream<T>(callback: (response: Response) => Promise<T>, method: HttpMethod, path: string, queryParams?: Values, body?: any, options?: Partial<ITransportSettings>): Promise<T>;
    get<TSuccess, TError>(path: string, queryParams?: Values, body?: any, options?: Partial<ITransportSettings>): Promise<SDKResponse<TSuccess, TError>>;
    head<TSuccess, TError>(path: string, queryParams?: Values, body?: any, options?: Partial<ITransportSettings>): Promise<SDKResponse<TSuccess, TError>>;
    delete<TSuccess, TError>(path: string, queryParams?: Values, body?: any, options?: Partial<ITransportSettings>): Promise<SDKResponse<TSuccess, TError>>;
    post<TSuccess, TError>(path: string, queryParams?: Values, body?: any, options?: Partial<ITransportSettings>): Promise<SDKResponse<TSuccess, TError>>;
    put<TSuccess, TError>(path: string, queryParams?: Values, body?: any, options?: Partial<ITransportSettings>): Promise<SDKResponse<TSuccess, TError>>;
    patch<TSuccess, TError>(path: string, queryParams?: Values, body?: any, options?: Partial<ITransportSettings>): Promise<SDKResponse<TSuccess, TError>>;
}
export declare function responseMode(contentType: string): ResponseMode;
export declare function isUtf8(contentType: string): RegExpMatchArray | null;
export type Values = {
    [key: string]: any;
} | null | undefined;
export declare function encodeParam(value: any): any;
export declare function encodeParams(values?: Values): string;
export declare function addQueryParams(path: string, obj?: Values): string;
export declare function sdkError(response: any): LookerSDKError;
export declare function sdkOk<TSuccess, TError>(promise: Promise<SDKResponse<TSuccess, TError>>): Promise<TSuccess>;
export declare function safeBase64(u8: Uint8Array): string;
export declare function isErrorLike<T>(error: T): error is T & {
    message: string;
};
export declare function jittery(attempt: number, baseDelayMs?: number, maxDelayMs?: number, jitterFactor?: number): number;
export declare function retryWait(wait: IWait): Promise<IWaitResponse>;
export declare function pauseForRetry(rawRequest: IRawRequest, rawResponse: IRawResponse, attempt: number, waiter?: Waitable): Promise<IWaitResponse>;
export declare const mergeOptions: (base: Partial<ITransportSettings>, custom: Partial<ITransportSettings>) => Partial<ITransportSettings>;
export declare function initResponse(method: HttpMethod, requestPath: string): IRawResponse;
export declare function retryError(response: IRawResponse): IRawResponse;
export declare function verifySsl(options?: Partial<ITransportSettings>): boolean | undefined;
export declare function sdkTimeout(options?: Partial<ITransportSettings>): number;
